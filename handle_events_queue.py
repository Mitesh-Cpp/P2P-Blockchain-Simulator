import heapq
from block import block
import peer_utils
import numpy as np
import uuid
from peer_utils import find_longest_chain, block_present, verify_all_transactions, add_block_to_tree, calculate_latency


def handle_events_queue(all_event_list, all_peers, args):

    def handle_mine_on_private_block_event(all_peers, current_event):
        print("xyz")
        adv_idx = current_event[2]
        current_time = current_event[0]
        Tb = current_event[3]
        block_to_mine_on = current_event[4]
        print("check: ", adv_idx, " ", current_time, " ", Tb)
        if block_to_mine_on != all_peers[adv_idx].private_chain[-1]:
            return
        prev_block_id = block_to_mine_on.id

        # Exponential time to mine the block based on hashing power
        random_time = int(np.random.exponential(scale=(1.0*Tb)/all_peers[adv_idx].hashing_power))
        
        # Time at which Block's POW is done
        block_generation_time = current_time + random_time

        # Create new block
        new_block = block(str(uuid.uuid4()), prev_block_id, all_peers[adv_idx].id, int(block_generation_time))
        
        # Fill it with transactions
        new_block.fill_block_with_transactions(all_peers[adv_idx],all_peers, current_time)

        # Call propagate event
        if block_generation_time <= args.To:
            heapq.heappush(all_event_list, all_peers[adv_idx].generate_block_propagate_event(new_block, block_generation_time, adv_idx, current_time))


    def handle_release_private_chain_event(all_peers, current_event):
        adv_idx = current_event[2]  
        print("yo: ", adv_idx)
        current_time = current_event[0]
        num_release_blocks = current_event[3]
        print("Num release blocks: ", num_release_blocks)
        for blk_num in range(num_release_blocks):
            for nbr in all_peers[adv_idx].connected_nodes:
                # calculates and adds the latency between adjecent peer and current peer
                print(len(all_peers[adv_idx].private_chain))
                print(blk_num)
                time = current_time + calculate_latency(all_peers, adv_idx, nbr, (1 + len(all_peers[adv_idx].private_chain[blk_num].transactions))*8*1000)
                heapq.heappush(all_event_list, all_peers[nbr].generate_block_propagate_event(all_peers[adv_idx].private_chain[blk_num], time, nbr, 0))
            
        for blk_num in range(num_release_blocks):
            all_peers[adv_idx].private_chain.pop(0)
            all_peers[adv_idx].adv_state -= 1
        
        print("Adversary State: ", adv_idx, " : ", all_peers[adv_idx].adv_state)

    def handle_block_propogate_event(all_peers, current_event):

        sender_idx = current_event[3]
        current_time = current_event[0]
        block_mining_start_time = current_event[5]

        # if the block is generated by an adversary, then add the block to its private chain. No need to propogate the block yet.
        if(sender_idx == len(all_peers)-2 and current_event[2].miner_id == len(all_peers)-2) or (sender_idx == len(all_peers)-1 and current_event[2].miner_id == len(all_peers)-1):
            # print("Block generated by adversary ", sender_idx, " It's state is: ", all_peers[sender_idx].adv_state+1)
            all_peers[sender_idx].private_chain.append(current_event[2])
            random_time = int(np.random.exponential(scale=(1.0*args.Tb)/all_peers[sender_idx].hashing_power))
            block_generation_time = current_time + random_time
            heapq.heappush(all_event_list, all_peers[sender_idx].generate_mine_on_private_block_event(block_generation_time, all_peers[sender_idx].private_chain[-1]))
            all_peers[sender_idx].adv_state += 1
            print("Adversary State: ", sender_idx, " : ", all_peers[sender_idx].adv_state)
            return

        # Reject blocks of the peer, which while mining, longest chain got changed now these are not valid
        if sender_idx < len(all_peers)-2 and current_event[2].miner_id == sender_idx:
            if block_mining_start_time < all_peers[sender_idx].latest_mine_block_event_time:
                return

        # Reject Propagate event if block is already present in the Tree or Blocks transactions lead to negative balance of peers 
        if not(block_present(all_peers[sender_idx], current_event[2])) and verify_all_transactions(all_peers, all_peers[sender_idx], current_event[2]):
            
            # Adds the block to blockchain tree
            add_block_to_tree(all_peers[sender_idx], current_event[2])
            
            new_longest_chain_length = len(find_longest_chain(all_peers[sender_idx].genesis_block))

            # Start mining new block if longest chain length is increased
            if new_longest_chain_length > all_peers[sender_idx].previous_longest_chain_length:
                # for honest nodes
                if sender_idx < len(all_peers)-2:
                    heapq.heappush(all_event_list, all_peers[sender_idx].generate_mine_block_event(current_event[0]))
                # for adversary nodes
                else:
                    if all_peers[sender_idx].adv_state == 0:
                        all_peers[sender_idx].private_chain.clear()
                        heapq.heappush(all_event_list, all_peers[sender_idx].generate_mine_block_event(current_event[0]))
                    elif all_peers[sender_idx].adv_state == 1 or all_peers[sender_idx].adv_state == 2:
                        print("Adversary state is: ", all_peers[sender_idx].adv_state, " and queue size is: ", len(all_peers[sender_idx].private_chain))
                        heapq.heappush(all_event_list, all_peers[sender_idx].generate_release_private_chain_event(current_event[0], all_peers[sender_idx].adv_state))
                        # all_peers[sender_idx].adv_state = 0
                        heapq.heappush(all_event_list, all_peers[sender_idx].generate_mine_on_private_block_event(current_event[0], all_peers[sender_idx].private_chain[-1]))
                        # all_peers[sender_idx].private_chain.clear()
                    else:
                        print("Adversary state is: ", all_peers[sender_idx].adv_state, " and queue size is: ", len(all_peers[sender_idx].private_chain))
                        heapq.heappush(all_event_list, all_peers[sender_idx].generate_release_private_chain_event(current_event[0], 1))
                        # all_peers[sender_idx].adv_state -= 1
                        # all_peers[sender_idx].private_chain.pop(0)
                
                all_peers[sender_idx].latest_mine_block_event_time = current_event[0]
                all_peers[sender_idx].previous_longest_chain_length += 1

             # adversaries do not propoagate any other block
            if (sender_idx == len(all_peers)-1 and sender_idx != current_event[2].miner_id) or (sender_idx == len(all_peers)-2 and sender_idx != current_event[2].miner_id):
                return
            # Propagate block to all adjecent peers of the current peer
            for nbr in all_peers[sender_idx].connected_nodes:

                # calculates and adds the latency between adjecent peer and current peer
                time = current_event[0] + calculate_latency(all_peers, sender_idx, nbr, (1 + len(current_event[2].transactions))*8*1000)
                heapq.heappush(all_event_list, all_peers[nbr].generate_block_propagate_event(current_event[2], time, nbr, block_mining_start_time))

        else:
            if(current_event[2].miner_id >= len(all_peers)-2):
                print("Block Rejected..!!")
                print(not(block_present(all_peers[sender_idx], current_event[2])))
                print(verify_all_transactions(all_peers, all_peers[sender_idx], current_event[2]))
    
    def handle_transaction_propogate_event(all_peers, current_event):
        current_peer = all_peers[current_event[7]]
        current_time = current_event[0]
        txn_id = current_event[2]
        txn_sender_id = current_event[3]
        txn_receiver_id = current_event[4]
        coins = current_event[5]
        sender_id = current_event[6]

        # If transaction is already in the transaction pool, then don't propagate it. We've already propagated it.
        if txn_id in current_peer.transaction_pool:
            return

        # Add Transaction to miner's pool
        current_peer.transaction_pool.add(txn_id)
        current_peer.transaction_dict[txn_id] = current_event
        
        # Propagate transaction to all adjecent peers of the current peer
        for nbr in current_peer.connected_nodes:
            
            # Calculate total latency of the link
            latency = calculate_latency(all_peers, current_peer.id, nbr, 8000)                
            heapq.heappush(all_event_list, [current_time + latency, "transaction_propogate_event", txn_id, txn_sender_id, txn_receiver_id, coins, current_peer.id,  nbr])

    def handle_generate_transaction_event(all_peers, current_event):
        current_time = current_event[0]
        txn_id = current_event[2]
        txn_sender_id = current_event[3]
        txn_receiver_id = current_event[4]
        coins = current_event[5]

        # Call propagate event
        heapq.heappush(all_event_list, [current_time, "transaction_propogate_event", txn_id, txn_sender_id, txn_receiver_id, coins, txn_sender_id, txn_sender_id])
        return

    def handle_mine_block_event(all_peers, current_event):
        creator_idx = current_event[2]  
        current_time = current_event[0]
        Tb = current_event[3]

        # List containing all block in the visible longest chain (VLC) from genesis block
        longest_chain = find_longest_chain(all_peers[creator_idx].genesis_block)

        # On which block, the creator_idx miner should mine..??
        
        if creator_idx < len(all_peers)-2 or all_peers[creator_idx].adv_state == 0:
            # Last block of the longest chain
            prev_block_id = longest_chain[-1].id if longest_chain else None

        else:
            prev_block_id = all_peers[creator_idx].private_chain[-1].prev_block_id

        

        # Exponential time to mine the block based on hashing power
        random_time = int(np.random.exponential(scale=(1.0*Tb)/all_peers[creator_idx].hashing_power))
        
        # Time at which Block's POW is done
        block_generation_time = current_time + random_time

        # Create new block
        new_block = block(str(uuid.uuid4()), prev_block_id, all_peers[creator_idx].id, int(block_generation_time))
        
        # Fill it with transactions
        new_block.fill_block_with_transactions(all_peers[creator_idx],all_peers, current_time)

        # Call propagate event
        if block_generation_time <= args.To:
            heapq.heappush(all_event_list, all_peers[creator_idx].generate_block_propagate_event(new_block, block_generation_time, creator_idx, current_time))

    while all_event_list:
        current_event = heapq.heappop(all_event_list)
        event_type = current_event[1]

        print(current_event[0], flush = True)

        # Perform operations based on the event type
        if event_type == "generate_transaction_event":
            handle_generate_transaction_event(all_peers, current_event)
        elif event_type == "mine_block_event":
            handle_mine_block_event(all_peers, current_event)
        elif event_type == "block_propagate_event":
            handle_block_propogate_event(all_peers, current_event)
        elif event_type == "transaction_propogate_event":
            handle_transaction_propogate_event(all_peers, current_event)
        elif event_type == "release_private_chain_event":
            handle_release_private_chain_event(all_peers, current_event)
        elif event_type == "mine_on_private_block_event":
            handle_mine_on_private_block_event(all_peers, current_event)
    
    # handle_release_private_chain_event(all_peers, all_peers[len(all_peers)-2].generate_release_private_chain_event(0, len(all_peers[len(all_peers)-2].private_chain)))
    # handle_release_private_chain_event(all_peers, all_peers[len(all_peers)-1].generate_release_private_chain_event(0, len(all_peers[len(all_peers)-1].private_chain)))
   
#     heapq.heappush(all_event_list, all_peers[len(all_peers)-2].generate_release_private_chain_event(0, len(all_peers[len(all_peers)-2].private_chain)))
#     heapq.heappush(all_event_list, all_peers[len(all_peers)-1].generate_release_private_chain_event(0, len(all_peers[len(all_peers)-1].private_chain)))

#     while all_event_list:
#         current_event = heapq.heappop(all_event_list)
#         event_type = current_event[1]

#         print(current_event[0], flush = True)

#         # Perform operations based on the event type
#         if event_type == "generate_transaction_event":
#             handle_generate_transaction_event(all_peers, current_event)
#         elif event_type == "mine_block_event":
#             handle_mine_block_event(all_peers, current_event)
#         elif event_type == "block_propagate_event":
#             handle_block_propogate_event(all_peers, current_event)
#         elif event_type == "transaction_propogate_event":
#             handle_transaction_propogate_event(all_peers, current_event)
#         elif event_type == "release_private_chain_event":
#             handle_release_private_chain_event(all_peers, current_event)
#         elif event_type == "mine_on_private_block_event":
#             handle_mine_on_private_block_event(all_peers, current_event)
    
                        
# # all_peers[len(all_peers)-2].generate_release_private_chain_event(0, len(all_peers[len(all_peers)-2].private_chain))